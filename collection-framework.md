# 컬렉션 프레임워크
본 내용은 [이것이 자바다 - 신용권], [김영한 중급 2편]을 참고하여 정리하였습니다.

<br/>

> 1절. 컬렉션 프레임워크 소개 
> 
> 2절. List 컬렉션
>
> 3절. Set 컬렉션
> 
> 4절. Map 컬렉션
>
> 5절. 검색 기능을 강화시킨 컬렉션
>
> 6절. LIFO와 FIFO
> 
> 7절. 동기화된 컬렉션
> 
> 8절. 병렬 처리를 위한 컬렉션

<br/>

## 1. 컬렉션 프레임워크 소개
### 개요
자바는 배열의 한계를 보완하기 위해, 널리 알려진 자료구조들을 기반으로 효율적인 추가, 삭제, 검색이 가능하도록 `java.util` 패키지에 컬렉션과 관련된 인터페이스뿐 아니라 이를 구현한 클래스들까지 포함시켰으며, 이를 컬렉션 프레임워크라고 한다.

<br/>

### 컬렉션
- 사전적 의미로는 요소를 수집해서 저장하는 것을 말한다.
- 자바 컬렉션은 객체를 수집해서 저장하는 역할을 한다.

<br/>

### 프레임 워크
- 사용 방법을 미리 정해 놓은 라이브러리를 말한다.

<br/>

> 아래는 해당 인터페이스를 구현한 클래스들이다.

|인터페이스 분류|    특징 | 구현 클래스|
|:-------:|:------|:-------|
|Collection - <br/>List 계열|순서를 유지하고 저장 <br/>중복 저장 가능 | ArrayList, Vector, LinkedList|
|Collection - <br/>Set 계열|순서를 유지하지 않고 저장 <br/>중복 저장 안됨 | HashSet, TreeSet|
|Map 계열|키와 값의 쌍으로 저장 <br/> 키는 중복 저장 안됨 | HashMap, Hashtable, <br/> TreeMap, Properties|

<br/>


## 2. List 컬렉션
### List 특징
- 객체를 순서대로 저장하며, 인덱스로 객체를 관리하는 자료구조이다.
- 객체를 저장하면 자동으로 인덱스가 부여되며, 저장되는 것은 객체 그 자체가 아닌 객체의 참조이다.

<br/>

### ArrayList
- 배열 기반의 List 구현체로, 인덱스를 이용해 객체를 관리한다.
- 일반 배열과 달리, 배열의 크기는 저장 용량(capacity)를 초과하면 자동으로 50% 증가한다.
- 중간 또는 앞쪽에 삽입/삭제 시 뒤쪽 요소를 한 칸씩 이동해야 하므로 성능이 저하된다.
	- `System.arraycopy()`를 활용한 고속 복소라 성능을 개선하였다.
 - 요소들이 메모리상에서 연속적으로 위치하고 있어 CPU 캐시 효율이 높다.

<br/>

### LinkedList
- 이중 연결 리스트 구조로 각 요소가 노드 형태이며, 앞뒤 노드의 참조를 가진다.
- 중간 삽입/삭제 시에는 단순히 링크만 변경하면 되므로 이론적으로 효율적이다.
- 하지만, 삽입/삭제 위치를 찾기 위해 노드를 순차적으로 탐색해야 하므로 접근 속도가 느리다.
	- 인덱스 방식이지만, 실제로는 포인터를 따라 노드를 순차 탐색한다.
- 처음과 끝에서의 삽입/삭제는 포인터로 직접 접근 가능하므로 O(1)의 성능을 보인다.

<br/>

### ArrayList와 LinkedList 성능 비교

| 기능             | 배열 리스트 (ArrayList)     | 연결 리스트 (LinkedList)    |
|------------------|-----------------------------|------------------------------|
| 앞에 추가/삭제   | O(n) - 약 106ms             | O(1) - 약 2ms                |
| 평균 추가/삭제   | O(n) - 약 49ms              | O(n) - 약 1116ms            |
| 뒤에 추가/삭제   | O(1) - 약 1ms               | O(1) - 약 2ms                |
| 인덱스 조회 (`get`) | O(1) - 약 1ms               | O(n) - 평균 약 439ms        |
| 검색 (`indexOf`) | O(n) - 평균 약 104ms       | O(n) - 평균 약 473ms        |


<br>

> ArrayList는 메모리상에 요소들이 연속적으로 저장되기 때문에 CPU 캐시 효율이 높고, 객체 접근 속도도 빨라 대부분의 상황에서 더 우수한 성능을 보인다. 반면, LinkedList는 앞부분에서 자주 삽입/삭제하는 경우 포인터만 조작하기 때문에 효율적이다.

<br/>

## 3. Set 컬렉션
### Set 특징
- 중복된 데이터를 저장하지 않으며, 저장 순서를 유지하지 않는다.
- `null` 값은 하나만 허용된다.
- 인덱스로 접근할 수 없고, 대신 Iterator를 통해 요소를 순차 접근한다.

<br>

**Iterator 사용 예시**
```java
Set<String> set = ...;
Iterator<String> iterator = set.iterator();

while(iterator.hasNext()) { // 가져올 객체가 있는지 확인
	String str = iterator.next(); // 객체 반환
	if(str.equals("홍길동")) {
		iterator.remove(); 
        //remove는 Iterator의 메소드이지만, 실제 Set 컬렉션에서 객체가 제거
	}
}
```

<br>

### Set의 성능 문제
- `add()`나 `contains()` 수행 시, 내부적으로 중복 여부 확인을 위해 전체를 순회해야 한다.
- 이로 인해, 시간 복잡도는 O(n)으로, 데이터가 많아질 수록 성능이 저하된다.
-> 보완 필요
  
<br>

### Hash
### 사용 이유
- 해시 알고리즘을 이용하면 데이터를 빠르게 저장하고 검색할 수 있다.
- 해시 함수로 해시 인덱스(HashIndedx)를 계산하고, 이를 기준으로 데이터를 저장한다.
- 평균 시간 복잡도는 O(1)이지만, 해시 충돌 발생이 발생하면 최악의 경우 O(n)까지 성능이 떨어질 수 있다.

<br>

### Hash Table 구조

| 구성요소          | 설명                                             |
| ------------- | ------------------------------------------------- |
| **Buckets**   | 해시 테이블을 구성하는 배열 전체                          |
| **Bucket**    | Buckets 배열의 각 요소로, **같은 해시 인덱스를 공유하는 데이터 그룹**을 저장 |
| **HashIndex** | 해시 함수로부터 계산된 인덱스 값으로, Bucket의 위치를 지정함               |

<br>

### Hash 용어 정리

| 용어         | 정의                               |
| ---------- | -------------------------------- |
| **해시 함수**  | 데이터를 입력받아 고정된 길이의 정수값(해시 코드)로 변환하는 과정 |
| **해시 코드**  | 해시 함수의 결과값으로, 데이터를 대표하는 정수값      |
| **해시 인덱스** | 해시 코드를 기반으로 계산된 실제 배열 위치         |

> 어떤 입력에도 자바의 `hashCode()`를 통해서, 해시 코드(해시값)인 정수값을 만들어낸다.

> 다른 입력에도 같은 해시 인덱스에 저장될 수 있으며, 이를 해시 충돌이라고 한다.

> 해시 인덱스는 실제 저장 위치를 정하는 것이므로, 해시 충돌은 해시 인덱스 기준으로 발생한다. 해시값(해시 코드)은 해시 함수가 정한 중간 단계일 뿐이다.

<br>

### 충돌 해결: 체이닝 방식
- 같은 해시 인덱스에 여러 데이터가 매핑될 경우, 해당  Bucket에 선형 자료구조(리스트 등)를 연결해 저장한다.
- 일반적으로 LinkedList를 사용한다.
	- 포인터만 조작해 삽입/삭제가 가능하여 구조 변경 비용이 낮다.
 	- 배열 기반보다 충돌 시 처리 성능이 안정적이다.

<br>

### HashSet
- HashSet은 Set 인터페이스를 구현한 대표적인 클래스이다.
- 객체를 저장할 때 순서를 고려하지 않고, 동일한 객체는 한 번만 저장된다.
- 데이터 양이 배열 크기의 75%를 넘어가면 배열의 크기를 2배로 늘리고, 늘어난 크기를 기준으로 모든 요소를 해시 인덱스에 다시 적용한다 (Rehashing)

<br>

> 여기서 "동일한 객체"란 단순히 같은 인스턴스를 의미하는 것이 아니라, 객체의 `hashCode()`와 `equals()` 메서드의 결과를 기준으로 논리적 동등성을 판단한 것이다.



<br>

### equals()

- 동일성(Identity): `==` 연산자를 사용해서 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인한다.
- 동등성(Equality): equals() 메서드를 사용해서 두 객체가 논리적으로 같은 값을 가지는지 확인한다.

<br>

- Object` 클래스의 `equals()` 기본 구현은 `==`과 동일하게 참조 비교를 하기 때문에 동일성을 검사한다.
- 하지만 많은 클래스(String, Integer, List 등)는 `equals()`를 오버라이딩해서 내용 비교, 즉 동등성을 검사하도록 구현되어 있다.
- 직접 만든 클래스의 경우에는 `equals()` 메서드를 재정의할 수있다 or 해야만 한다

<br>

> 즉, `equals()`의 비교 결과는 해당 클래스가 어떻게 오버라이딩했는지에 따라 다르다.

<br>

**equals()가 사용되는 시점**
```java
public boolean contains(Object searchValue) {
	int hashIndex = hashIndex(searchValue);
	LinkedList<Object> bucket = buckets[hashIndex];
	for(Object object: bucket) {
		if(object.equals(searchValue) {
		return true;
		}
	}
	return false;
	// return bucket.contains(searchValue);
}
```
- LinkedList의 `contains()` 메소드 안 `equals()`가 값들을 전부 비교한다.

<br>

> LinkedList는 자바가 자체적으로 `contains()`에 `equals()`를 이용하도록 구현하였고, 비교 기준은 결국 요소 타입의 `equals()` 재정의 여부에 달려있다.

<br>

### hashCode()
- 기본적으로 Object 클래스의 `hashCode()`는 객체의 참족밧을 기반으로 한 정수값을 반환한다.
	- 객체의 인스턴스가 다르면 해시 코드도 다르다.
 - 하지만, `equals()`처럼 대부분의 클래스에서는 `hashCode()`를 오버라이딩한다.
 - String,, Integer, List 등 주요 클래스들은 객체의 값 기반으로 hashCode()를 오버라이딩 되어있다.
 -  직접 만든 객체의 경우 원하는 값으 바탕으로 해시코드를 생성하도록 직접 오버라이딩 할 수 있다. or 해야만 한다
 - 즉, 어떤 해시값이 반환되는지는 해당 클래스가 `hashCode()` 어떻게 정의했는지에 따라 다르다.


### equals, hashCode의 중요성

Bucket에 담긴 데이터가 하나라면 equals() 없이 반환해도 되지 않을까?
해시 인덱스가 같지만, 실제 값은 다를 수 있기 때문에 무조건 equals()를 사용해야 한다.

1. equals, HashCode 둘 다 미구현
- 각 객체의 해시코드가 다르기 때문에, 각 데이터가 다른 Bucket에 저장될 수 있다.
- 데이터를 버킷에 저장할 때, equals()가 참조값을 기반으로 비교하기 때문에 데이터가 중복 저장된다.
- 검색의 경우, 검색을 위해 새로 생성한 객체의 해시코드가 다르기 때문에 검색할 해시 인덱스도 다르다.
- 만약, 해시 인덱스가 같은 상황이라도 equals()가 참조값을 바탕으로 비교하기 때문에 false가 반환된다.

2. hashCode만 구현, equals 미구현
	- 각 객체의 해시코드는 같으면, 해시 인덱스를 올바르게 찾아가지만, equals()에서 각 객체를 다른 객체로 보기 때문에 데이터가 중복 저장된다.
	- 검색의 경우, 해시 인덱스는 정확하게 찾지만, 데이터를 찾을때 참조값이 달라 찾지 못하고 false 반

따라서 equals(), hashCode() 둘다 구현해야한다.



<br>



















## 4. Map 컬렉션
### Map 특징
- **Map 컬렉션은 키(Key)와 값(Value)의 쌍으로 구성된 Entry 객체를 저장하는 구조를 가지고 있다.**
  - 키와 값은 모두 객체로 저장된다.
  - 키는 중복 저장이 불가능하며, 중복된 키로 값을 저장할 경우 기존 값이 새 값으로 대체된다.
  - 값은 중복 저장이 가능하다.
    
<br>

### HashMap
-  HashMap은 Map 인터페이스를 구현한 대표적인 Map 컬렉션이다.
-  HashMap의 키로 사용할 객체는 `hashCode()`와 `equasl()` 메소드를 재정의해서 동등 객체가 될 조건을 명확히 해야한다.
    - 키의 중복 여부를 이 두 메서드를 통해 판단한다.


<br>

### Hashtable
- Hashtable은 HashMap과 동일한 내부 구조를 가지고 있다.
- 차이점은 Hashtable은 동기화된(synchronized) 메소드로 구성되어 있다.

<br>

### Properties
- 애플리케이션이나 데이터베이스 등의 정보가 저장된 프로퍼티(*.properties) 파일을 읽을 때 주로 사용된다.
- 이는 Hashtable의 하위 클래스이기 때문에 Hashtable의 모든 특징을 그대로 가진다.
  - 차이점은 Hashtable은 키와 값을 다양한 타입으로 지정이 가능한데 비해, Properties는 키와 값을 `String`타입으로 제한한 컬렉션이다. 


<br>

## 5. 검색 기능을 강화시킨 컬렉션
### 개요
- 컬렉션 프레임워크는 검색 기능을 강화시킨 TreeSet과 TreeMap을 제공한다.
- 이진 트리를 이용해서 계층적 구조를 가지면서 객체를 .


<br>

### TreeSet
- TreeSet은 Set 인터페이스를 구현한 클래스로, 중복 없이 데이터를 저장한다.
- 내부적으로 이진 탐색 트리를 사용해 저장된 데이터가 항상 오름차순으로 정렬되어 있다.

<br>

### TreeMap
- TreeMap은 Map 인터페이스를 구현한 컬렉션이다.
- 내부 구조는 TreeSet과 비슷한 이진 탐색 트리이며, 키를 기준으로 데이터를 정렬해 저장한다.

<br>

### Compareable, Comparator
- TreeSet과 TreeMap은 저장하는 순간, 자동으로 키나 객체를 오름차순으로 졍렬한다.
- 이를 위해 저장되는 객체는 Comparable 인터페이를 구현해야 한다.
	- Comparable 인터페이스는 `compareTo()` 메서드가 있어서 두 객체를 비교하는 기준을 정할 수 있다.

### TreeSet 객체와 TreeMap의 키가 Comparable을 구현하고 있지 않을 경우
- 저장할 때 `ClassCastException` 오류가 발생한다.
- 자바가 두 객체를 비교하는 방법을 몰라서 발생하는 문제이다.
  

<br>

## 6. LIFO와 FIFO 컬렉션
### 개요
- 후입선출(LIFO: Last In First Out): 나중에 넣은 객체가 먼저 빠져나가는 자료구조
- 선입선출(FIFO: First In First Out): 먼저 넣은 객체가 먼저 빠져나가는 자료구조

> 컬렉션 프레임워크에는 LIFO 자료구조를 제공하는 스택(Stack) 클래스와 FIFO 자료구조를 제공하는 큐(Queue) 인터페이스를 제공하고 있다.

### Stack
- 스택 클래스는 LIFO 자료구조를 구현한 클래스이다.
```java
Stack<E> stack = new Stack<E>();
```
### Queue
- 큐 인터페이스는 FIFO 방식으로 동작한다.
  - Queue 인터페이스를 구현한 대표적인 클래스는 LinkedList이다.
```java
Queue<E> queue = new LinkedList<E>();
```

<br>

## 7. 동기화된 컬렉션
### 개요
- 컬렉션 프레임워크의 대부분의 클래스들은 싱글 스레드 환경에서 사용할 수 있도록 설계됐다.
- 따라서, 여러 스레드가 동시에 컬렉션에 접근한다면 의도하지 않게 요소가 변경될 수 있는 불안전한 상태가 된다.

<br>

> 따라서 컬렉션 프레임워크는 비동기화된 메소드를 동기화된 메소드로 래핑하는 Collections의 sychronizedXXX()의 메소드를 제공하고 있다.

<br>

**동기화된 컬렉션으로 리턴하기**

|리턴 타입|  메소드(매개 변수) | 설명|
|:-------:|:------|:-------|
|List<T> | synchronizedList(List<T> list) | List를 동기화된 List로 리턴|
|Map<K, V> | synchronizedMap(Map<K, V> m) | Map을 동기화된 Map으로 리턴|
|Set<T> | synchronizedSet(Set<T> s) | Set을 동기화된 Set으로 리턴|

<br>



## 8. 병렬 처리를 위한 컬렉션
### 개요
- 동기화된 컬렉션은 멀티 스레드 환경에서 하나의 스레드가 요소를 안전하게 처리하도록 도와주지만, 전체 요소를 빠르게 처리하지는 못한다.
	- 이는 하나의 스레드가 요소를 처리할 때, 전체 잠금이 발생하여 다른 스레드는 대기 상태가 되기 때문이다.

<br>

> 따라서 자바는 멀티 스레드가 병렬적으로 처리할 수 있도록 특별한 컬렉션을 제공한다.

<br>

 ### ConcurrentHashMap
- 스레드에 안전하면서도 멀티 스레드가 요소를 병렬적으로 처리할 수 있게 도와준다.

```java
Map<K, V> map = new ConcurrentHashMap<K, V>();
```
- ConcurrentHashMap은 부분 잠금을 사용한다.
	- 전체 잠금: 1개를 처리할 동안 전체의 10개 요소를 다른 스레드가 처리하지 못하도록 하는 것
 	- 부분 잠금: 처리하는 요소가 포함된 부분만 잠금하고, 나머지 부분은 다른 스레드가 변경할 수 있는 것  

<br>

 ### ConcurrentLinkedQueue
 - 락-프리(lock-free) 알고리즘을 구현한 컬렉션이다.

```java
Queue<E> queue = new ConcurrentLinkedQueue<E>();
```
- 락-프리 알로리즘은 여러 갱의 스레드가 동시에 접근할 경우, 잠금을 사용하지 않도고 최소한 하나의 스레드가 안전하게 요소를 저장하거나 얻도록 해준다.



