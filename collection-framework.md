# 컬렉션 프레임워크
본 내용은 [이것이 자바다 - 신용권], [김영한 중급 2편]을 참고하여 정리하였습니다.

<br/>

> 1절. 컬렉션 프레임워크 소개 
> 
> 2절. List 컬렉션
>
> 3절. Hash 알고리즘
>
> 4절. Set 컬렉션
> 
> 5절. Map 컬렉션
>
> 6절. 검색 기능을 강화시킨 컬렉션
>
> 7절. LIFO와 FIFO
> 
> 8절. 동기화된 컬렉션
> 
> 9절. 병렬 처리를 위한 컬렉션

<br/>

## 1. 컬렉션 프레임워크 소개
### 개요
자바는 배열의 한계를 보완하기 위해, 널리 알려진 자료구조들을 기반으로 효율적인 추가, 삭제, 검색이 가능하도록 `java.util` 패키지에 컬렉션과 관련된 인터페이스뿐 아니라 이를 구현한 클래스들까지 포함시켰으며, 이를 컬렉션 프레임워크라고 한다.

<br/>

### 컬렉션
- 사전적 의미로는 요소를 수집해서 저장하는 것을 말한다.
- 자바 컬렉션은 객체를 수집해서 저장하는 역할을 한다.

<br/>

### 프레임 워크
- 사용 방법을 미리 정해 놓은 라이브러리를 말한다.

<br/>

> 아래는 해당 인터페이스를 구현한 클래스들이다.

|인터페이스 분류|    특징 | 구현 클래스|
|:-------:|:------|:-------|
|Collection - <br/>List 계열|순서를 유지하고 저장 <br/>중복 저장 가능 | ArrayList, Vector, LinkedList|
|Collection - <br/>Set 계열|순서를 유지하지 않고 저장 <br/>중복 저장 안됨 | HashSet, TreeSet|
|Map 계열|키와 값의 쌍으로 저장 <br/> 키는 중복 저장 안됨 | HashMap, Hashtable, <br/> TreeMap, Properties|

<br/>


## 2. List 컬렉션
### List 특징
- 객체를 순서대로 저장하며, 인덱스로 객체를 관리하는 자료구조이다.
- 객체를 저장하면 자동으로 인덱스가 부여되며, 저장되는 것은 객체 그 자체가 아닌 객체의 참조이다.

<br/>

### ArrayList
- 배열 기반의 List 구현체로, 인덱스를 이용해 객체를 관리한다.
- 일반 배열과 달리, 배열의 크기는 저장 용량(capacity)를 초과하면 자동으로 50% 증가한다.
- 중간 또는 앞쪽에 삽입/삭제 시 뒤쪽 요소를 한 칸씩 이동해야 하므로 성능이 저하된다.
	- `System.arraycopy()`를 활용한 고속 복소라 성능을 개선하였다.
 - 요소들이 메모리상에서 연속적으로 위치하고 있어 CPU 캐시 효율이 높다.

<br/>

### LinkedList
- 이중 연결 리스트 구조로 각 요소가 노드 형태이며, 앞뒤 노드의 참조를 가진다.
- 중간 삽입/삭제 시에는 단순히 링크만 변경하면 되므로 이론적으로 효율적이다.
- 하지만, 삽입/삭제 위치를 찾기 위해 노드를 순차적으로 탐색해야 하므로 접근 속도가 느리다.
	- 인덱스 방식이지만, 실제로는 포인터를 따라 노드를 순차 탐색한다.
- 처음과 끝에서의 삽입/삭제는 포인터로 직접 접근 가능하므로 O(1)의 성능을 보인다.

<br/>

### ArrayList와 LinkedList 성능 비교

| 기능             | 배열 리스트 (ArrayList)     | 연결 리스트 (LinkedList)    |
|------------------|-----------------------------|------------------------------|
| 앞에 추가/삭제   | O(n) - 약 106ms             | O(1) - 약 2ms                |
| 평균 추가/삭제   | O(n) - 약 49ms              | O(n) - 약 1116ms            |
| 뒤에 추가/삭제   | O(1) - 약 1ms               | O(1) - 약 2ms                |
| 인덱스 조회 (`get`) | O(1) - 약 1ms               | O(n) - 평균 약 439ms        |
| 검색 (`indexOf`) | O(n) - 평균 약 104ms       | O(n) - 평균 약 473ms        |


<br>

> ArrayList는 메모리상에 요소들이 연속적으로 저장되기 때문에 CPU 캐시 효율이 높고, 객체 접근 속도도 빨라 대부분의 상황에서 더 우수한 성능을 보인다. 반면, LinkedList는 앞부분에서 자주 삽입/삭제하는 경우 포인터만 조작하기 때문에 효율적이다.

<br/>

## 3. Hash 알고리즘
### Hash 특징
- 데이터를 빠르게 저장하고 검색할 수 있다.
- 해시 함수는 입력값을 정수형 해시 코드를 변환하고, 이를 기반으로 해시 인덱스를 계산해 배열의 위치를 결정한다.
- 평균적으로 시간 복잡도 O(1)의 성능을 제공하지만, 해시 충돌이 발생하면 최악의 경우 O(n)까지 성능이 저하될 수 있다.
- **해시 충돌이란, 서로 다른 데이터가 같은 해시 인덱스를 가지는 경우를 말한다.**

<br>

> 같은 해시코드를 가지더라도, 배열의 크기(capacity)에 따라 해시 인덱스는 달라질 수 있다. 보통 해시 인덱스는 `hashCode % capacity`로 계산되기 때문에, capacity가 변경되면 같은 해시코드로도 다른 인덱스를 가질 수 있다.

<br>

### Hash Table 구성 요소

| 구성 요소             | 설명                                            |
| ----------------- | --------------------------------------------- |
| **Hash Function** | 입력 데이터를 정수값(해시 코드)으로 변환하는 함수 (`hashCode()` 등) |
| **Hash Code**     | 해시 함수의 출력값으로, 객체를 대표하는 정수값                    |
| **Hash Index**    | 해시 코드를 기반으로 계산된 실제 저장 위치 (배열 인덱스)             |
| **Buckets**       | 해시 인덱스를 기준으로 데이터를 저장하는 전체 배열                  |
| **Bucket**        | Buckets 배열의 각 요소로, 같은 해시 인덱스를 공유하는 데이터 그룹     |

<br>

### 충돌 해결
- 해시 충돌이 발생하면 같은 해시 인덱스의 Bucket에 선형 자료구조(주로 LinkedList)를 연결해서 데이터를 저장한다. 
- LinkedList는 포인터 조작만으로 삽입과 삭제가 가능해 구조 변경 비용이 낮고, 배열 기반보다 충돌 처리에 더 효율적이다.

<br>

## 4. Set 컬렉션
### Set 특징
- 중복된 데이터를 저장하지 않으며, 저장 순서를 유지하지 않는다.
- `null` 값은 하나만 허용된다.
- 인덱스로 접근할 수 없고, 대신 Iterator를 통해 요소를 순차 접근한다.

<br>

**Iterator 사용 예시**
```java
Set<String> set = ...;
Iterator<String> iterator = set.iterator();

while(iterator.hasNext()) { // 가져올 객체가 있는지 확인
	String str = iterator.next(); // 객체 반환
	if(str.equals("홍길동")) {
		iterator.remove(); 
        //remove는 Iterator의 메소드이지만, 실제 Set 컬렉션에서 객체가 제거
	}
}
```

<br>

### Set의 성능 문제
- `add()`나 `contains()` 수행 시, **내부적으로 중복 여부 확인을 위해 전체를 순회해야 한다.**
- 이로 인해, 시간 복잡도는 O(n)으로, 데이터가 많아질 수록 성능이 저하된다.

<br>

### HashSet
- Hash 기반으로 구현된 Set 인터페이스의 대표적인 구현체이다.
- 객체를 저장할 때 순서를 고려하지 않고, 동일한 객체는 한 번만 저장된다.
- 저장된 데이터가 전체 배열 크기의 75%를 초과하면 배열 크기를 2배로 늘리고, 모든 요소를 다시 해시 인덱스에 재배치한다.
  
<br>

> 여기서 "동일한 객체"란 단순히 같은 인스턴스를 의미하는 것이 아니라, 객체의 `hashCode()`와 `equals()` 메서드의 결과를 기준으로 논리적 동등성을 판단한 것이다.

<br>

### equals()
- Object 클래스의 `equals()` 기본 구현은 `==`과 동일하게 참조 비교한다.
- String, Integer, List 등 자바 주요 클래스들은 객체의 값을 비교하도록 `equals()`를 오버라이딩한다.
- 직접 만든 클래스도 객체의 논리적 동등성을 판단하려면 `equals()`를 재정의해야 한다.


<br>

> 동일성(Identity): `==` 연산자를 사용해서 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인한다.  
> 동등성(Equality): `equals()` 메서드를 사용해서 두 객체가 논리적으로 같은 값을 가지는지 확인한다.

<br>

**equals()가 사용되는 시점**
```java
public boolean contains(Object searchValue) {
	int hashIndex = hashIndex(searchValue);
	LinkedList<Object> bucket = buckets[hashIndex];
	for(Object object: bucket) {
		if(object.equals(searchValue) {
		return true;
		}
	}
	return false;
	// return bucket.contains(searchValue);
}
```
- LinkedList의 `contains()` 메소드 내부적으로 `equals()`를 사용해 요소를 비교한다.
- 따라서 요소 타입의 `equals()` 구현 여부가 검색 정확도를 결정한다.

<br>

### hashCode()
- Object 클래스의 기본 `hashCode()`는 객체 참조값을 기반으로 해시코드를 생성한다.
- String, Integer, List 등 주요 클래스들은 값에 따라 같은 해시코드를 반환하도록 `hashCode()`를 오버라이딩한다.
- 직접 만든 클래스도 원하는 기준에 따라 일관된 해시코드를 생성하려면 `hashCode()`를 재정의해야 한다.

<br>

### equals, hashCode의 중요성

**1. equals, HashCode 둘 다 미구현**
- Object 클래스의 기본 구현은 객체의 참조값을 기준으로 `equals()`와 `hashCode()`를 처리한다.
- 이로 인해 객체마다 해시코드가 달라 서로 다른 버킷에 저장된다.
- 간혹 해시 충돌로 같은 버킷에 저장될 수는 있지만, `equals()`가 참조값을 비교하므로 내용이 같아도 중복 저장된다.
- 검색 시, 동일한 내용을 가진 새 객체는 다른 해시코드를 가지므로 다른 버킷을 탐색하게 된다.
- 설령 우연히 같은 버킷을 탐색하더라도 `equals()`가 참조값을 기준으로 비교하므로, 내용이 같아도 검색에 실패한다.

<br>

**2. hashCode만 구현, equals 미구현**
- `hashCode()`가 값 기반으로 구현되어, 같은 내용을 가진 객체는 동일한 버킷을 찾아간다.
- 하지만 `equals()`는 기본 구현 그대로 참조값을 비교하므로, 내용이 같아도 서로 다른 객체로 인식된다.
- 이로 인해 동일한 버킷 안에서도 중복 저장이 발생하고, 검색 시에도 `equals()`에서 참조값이 다르므로 일치하지 않아 검색에 실패한다.

<br>

> 직접 만든 클래스는 `equals()`와 `hashCode()`는 함께 오버라이딩해야 중복 저장을 방지하고 정확한 검색이 가능하다.

<br>

### LinkedHashSet
- HashSet에 이중 연결 리스트를 더해 요소의 삽입 순서를 보장한다.
- 요소는 노드의 형태로 버킷에 저장되고, 이 노드들이 연결 리스트로 순서를 유지한다.
- 정렬은 하지 않고, 단지 삽입 순서만 유지한다.

<br>

### TreeSet
- 내부적으로 레드-블랙 트리를 사용한다.
- 요소는 항상 정렬된 상태로 저장된다.
	- 정렬 기준은 기본 정렬(Comparable), 사용자 지정(Comparator)이 있다.
 - 모든 연산의 시간 복잡도는 O(log n)이다.
 - 순회 시 중위 순회 방식을 사용한다.
 - 데이터를 정렬된 상태로 저장하면서 집합의 특성을 유지해야 할 때 적합하다


<br>

## 5. Map 컬렉션
### Map 특징
- **Map 컬렉션은 키(Key)와 값(Value)의 쌍으로 구성된 Entry 객체를 저장하는 자료구조이다.**
- 키는 중복 저장이 불가능하며, 중복된 키로 값을 저장할 경우 기존 값이 새 값으로 대체된다.
- 값은 중복 저장이 가능하다.
    
<br>

### Map과 Set의 구조적 유사성
- Map의 Key 구조는 Set과 동일하여, HashMap과 HashSet, TreeMap과 TreeSet은 내부 구현이 매우 유사하다. 
- 실제로 HashSet은 내부적으로 HashMap을 이용해 Key만 저장하며, Value는 더미(dummy) 값으로 설정된다.

<br>

### HashMap
-  HashMap은 Map 인터페이스를 구현한 대표적인 Map 컬렉션이다.
-  Key로 사용할 객체는 `hashCode()`와 `equasl()` 메소드를 반드시 오버라이딩해야 한다.
-  두 메서드는 Key의 중복 여부를 판단하는 기준이 되며, 검색/저장/삭제 등 모든 연산은 Key를 기준으로 처리된다.
-  특히, `hashCode()`는 Value가 아닌 Key에만 사용된다.

<br>

### Hashtable
- Hashtable은 HashMap과 동일한 내부 구조를 가지고 있다.
- 차이점은 Hashtable은 동기화된(synchronized) 메소드로 구성되어 있다.

<br>

### Properties
- 애플리케이션이나 데이터베이스 등의 정보가 저장된 프로퍼티(*.properties) 파일을 읽을 때 주로 사용된다.
- 이는 Hashtable의 하위 클래스이기 때문에 Hashtable의 모든 특징을 그대로 가진다.
  - 차이점은 Hashtable은 키와 값을 다양한 타입으로 지정이 가능한데 비해, Properties는 키와 값을 `String`타입으로 제한한 컬렉션이다. 

<br>

## 5. 검색 기능을 강화시킨 컬렉션
### 개요
- 컬렉션 프레임워크는 검색 기능을 강화시킨 TreeSet과 TreeMap을 제공한다.
- 이진 트리를 이용해서 계층적 구조를 가지면서 객체를 .


<br>

### TreeSet
- TreeSet은 Set 인터페이스를 구현한 클래스로, 중복 없이 데이터를 저장한다.
- 내부적으로 이진 탐색 트리를 사용해 저장된 데이터가 항상 오름차순으로 정렬되어 있다.

<br>

### TreeMap
- TreeMap은 Map 인터페이스를 구현한 컬렉션이다.
- 내부 구조는 TreeSet과 비슷한 이진 탐색 트리이며, 키를 기준으로 데이터를 정렬해 저장한다.

<br>

### Compareable, Comparator
- TreeSet과 TreeMap은 저장하는 순간, 자동으로 키나 객체를 오름차순으로 졍렬한다.
- 이를 위해 저장되는 객체는 Comparable 인터페이를 구현해야 한다.
	- Comparable 인터페이스는 `compareTo()` 메서드가 있어서 두 객체를 비교하는 기준을 정할 수 있다.

### TreeSet 객체와 TreeMap의 키가 Comparable을 구현하고 있지 않을 경우
- 저장할 때 `ClassCastException` 오류가 발생한다.
- 자바가 두 객체를 비교하는 방법을 몰라서 발생하는 문제이다.
  

<br>

## 6. LIFO와 FIFO 컬렉션
### 개요
- 후입선출(LIFO: Last In First Out): 나중에 넣은 객체가 먼저 빠져나가는 자료구조
- 선입선출(FIFO: First In First Out): 먼저 넣은 객체가 먼저 빠져나가는 자료구조

> 컬렉션 프레임워크에는 LIFO 자료구조를 제공하는 스택(Stack) 클래스와 FIFO 자료구조를 제공하는 큐(Queue) 인터페이스를 제공하고 있다.

### Stack
- 스택 클래스는 LIFO 자료구조를 구현한 클래스이다.
```java
Stack<E> stack = new Stack<E>();
```
### Queue
- 큐 인터페이스는 FIFO 방식으로 동작한다.
  - Queue 인터페이스를 구현한 대표적인 클래스는 LinkedList이다.
```java
Queue<E> queue = new LinkedList<E>();
```

<br>

## 7. 동기화된 컬렉션
### 개요
- 컬렉션 프레임워크의 대부분의 클래스들은 싱글 스레드 환경에서 사용할 수 있도록 설계됐다.
- 따라서, 여러 스레드가 동시에 컬렉션에 접근한다면 의도하지 않게 요소가 변경될 수 있는 불안전한 상태가 된다.

<br>

> 따라서 컬렉션 프레임워크는 비동기화된 메소드를 동기화된 메소드로 래핑하는 Collections의 sychronizedXXX()의 메소드를 제공하고 있다.

<br>

**동기화된 컬렉션으로 리턴하기**

|리턴 타입|  메소드(매개 변수) | 설명|
|:-------:|:------|:-------|
|List<T> | synchronizedList(List<T> list) | List를 동기화된 List로 리턴|
|Map<K, V> | synchronizedMap(Map<K, V> m) | Map을 동기화된 Map으로 리턴|
|Set<T> | synchronizedSet(Set<T> s) | Set을 동기화된 Set으로 리턴|

<br>



## 8. 병렬 처리를 위한 컬렉션
### 개요
- 동기화된 컬렉션은 멀티 스레드 환경에서 하나의 스레드가 요소를 안전하게 처리하도록 도와주지만, 전체 요소를 빠르게 처리하지는 못한다.
	- 이는 하나의 스레드가 요소를 처리할 때, 전체 잠금이 발생하여 다른 스레드는 대기 상태가 되기 때문이다.

<br>

> 따라서 자바는 멀티 스레드가 병렬적으로 처리할 수 있도록 특별한 컬렉션을 제공한다.

<br>

 ### ConcurrentHashMap
- 스레드에 안전하면서도 멀티 스레드가 요소를 병렬적으로 처리할 수 있게 도와준다.

```java
Map<K, V> map = new ConcurrentHashMap<K, V>();
```
- ConcurrentHashMap은 부분 잠금을 사용한다.
	- 전체 잠금: 1개를 처리할 동안 전체의 10개 요소를 다른 스레드가 처리하지 못하도록 하는 것
 	- 부분 잠금: 처리하는 요소가 포함된 부분만 잠금하고, 나머지 부분은 다른 스레드가 변경할 수 있는 것  

<br>

 ### ConcurrentLinkedQueue
 - 락-프리(lock-free) 알고리즘을 구현한 컬렉션이다.

```java
Queue<E> queue = new ConcurrentLinkedQueue<E>();
```
- 락-프리 알로리즘은 여러 갱의 스레드가 동시에 접근할 경우, 잠금을 사용하지 않도고 최소한 하나의 스레드가 안전하게 요소를 저장하거나 얻도록 해준다.



