# 컬렉션 프레임워크
본 내용은 [이것이 자바다 - 신용권], [김영한 중급 2편]을 참고하여 정리하였습니다.

<br/>

> 1절. 컬렉션 프레임워크 소개 
> 
> 2절. List 컬렉션
>
> 3절. Set 컬렉션
> 
> 4절. Map 컬렉션
>
> 5절. 검색 기능을 강화시킨 컬렉션
>
> 6절. LIFO와 FIFO
> 
> 7절. 동기화된 컬렉션
> 
> 8절. 병렬 처리를 위한 컬렉션

<br/>

## 1. 컬렉션 프레임워크 소개
### 개요
자바는 배열의 한계를 보완하기 위해, 널리 알려진 자료구조들을 기반으로 효율적인 추가, 삭제, 검색이 가능하도록 `java.util` 패키지에 컬렉션과 관련된 인터페이스뿐 아니라 이를 구현한 클래스들까지 포함시켰으며, 이를 컬렉션 프레임워크라고 한다.

<br/>

### 컬렉션
- 사전적 의미로는 요소를 수집해서 저장하는 것을 말한다.
- 자바 컬렉션은 객체를 수집해서 저장하는 역할을 한다.

<br/>

### 프레임 워크
- 사용 방법을 미리 정해 놓은 라이브러리를 말한다.

<br/>

> 아래는 해당 인터페이스를 구현한 클래스들이다.

|인터페이스 분류|    특징 | 구현 클래스|
|:-------:|:------|:-------|
|Collection - <br/>List 계열|순서를 유지하고 저장 <br/>중복 저장 가능 | ArrayList, Vector, LinkedList|
|Collection - <br/>Set 계열|순서를 유지하지 않고 저장 <br/>중복 저장 안됨 | HashSet, TreeSet|
|Map 계열|키와 값의 쌍으로 저장 <br/> 키는 중복 저장 안됨 | HashMap, Hashtable, <br/> TreeMap, Properties|

<br/>


## 2. List 컬렉션
### List 특징
- 객체를 순서대로 저장하며, 인덱스로 객체를 관리하는 자료구조이다.
- 객체를 저장하면 자동으로 인덱스가 부여되며, 저장되는 것은 객체 그 자체가 아닌 객체의 참조이다.

<br/>

### ArrayList
- 배열 기반의 List 구현체로, 인덱스를 이용해 객체를 관리한다.
- 일반 배열과 달리, 배열의 크기는 저장 용량(capacity)를 초과하면 자동으로 50% 증가한다.
- 중간 또는 앞쪽에 삽입/삭제 시 뒤쪽 요소를 한 칸씩 이동해야 하므로 성능이 저하된다.
	- `System.arraycopy()`를 활용한 고속 복소라 성능을 개선하였다.
 - 요소들이 메모리상에서 연속적으로 위치하고 있어 CPU 캐시 효율이 높다.

<br/>

### LinkedList
- 이중 연결 리스트 구조로 각 요소가 노드 형태이며, 앞뒤 노드의 참조를 가진다.
- 중간 삽입/삭제 시에는 단순히 링크만 변경하면 되므로 이론적으로 효율적이다.
- 하지만, 삽입/삭제 위치를 찾기 위해 노드를 순차적으로 탐색해야 하므로 접근 속도가 느리다.
	- 인덱스 방식이지만, 실제로는 포인터를 따라 노드를 순차 탐색한다.
- 처음과 끝에서의 삽입/삭제는 포인터로 직접 접근 가능하므로 O(1)의 성능을 보인다.

<br/>

### ArrayList와 LinkedList 성능 비교

| 기능             | 배열 리스트 (ArrayList)     | 연결 리스트 (LinkedList)    |
|------------------|-----------------------------|------------------------------|
| 앞에 추가/삭제   | O(n) - 약 106ms             | O(1) - 약 2ms                |
| 평균 추가/삭제   | O(n) - 약 49ms              | O(n) - 약 1116ms            |
| 뒤에 추가/삭제   | O(1) - 약 1ms               | O(1) - 약 2ms                |
| 인덱스 조회 (`get`) | O(1) - 약 1ms               | O(n) - 평균 약 439ms        |
| 검색 (`indexOf`) | O(n) - 평균 약 104ms       | O(n) - 평균 약 473ms        |


<br>

> ArrayList는 메모리상에 요소들이 연속적으로 저장되기 때문에 CPU 캐시 효율이 높고, 객체 접근 속도도 빨라 대부분의 상황에서 더 우수한 성능을 보인다. 반면, LinkedList는 앞부분에서 자주 삽입/삭제하는 경우 포인터만 조작하기 때문에 효율적이다.

<br/>

## 3. Set 컬렉션
### Set 특징
- 중복된 데이터를 저장하지 않으며, 저장 순서를 유지하지 않는다.
- `null` 값은 하나만 허용된다.
- 인덱스로 접근할 수 없고, 대신 Iterator를 통해 요소를 순차 접근한다.

<br>

**Iterator 사용 예시**
```java
Set<String> set = ...;
Iterator<String> iterator = set.iterator();

while(iterator.hasNext()) { // 가져올 객체가 있는지 확인
	String str = iterator.next(); //객체 반환
	if(str.equals("홍길동")) {
		iterator.remove(); 
        //remove는 Iterator의 메소드이지만, 실제 Set 컬렉션에서 객체가 제거
	}
}
```

<br>

### Set의 성능 문제
- `add()`나 `contains()` 수행 시, 내부저으로 중복 여부 확인을 위해 전체를 순회해야 한다.
- 이로 인해, 시간 복잡도는 O(n)으로, 데이터가 많아질 수록 성능이 저하된다.
  
<br>

### 해시 알고리즘 도입 
- 데이터를 빠르게 저장하고 검색하기 위해 해시 알고리즘을 사용한다.
- 해시 함수로 해시 인덱스(HashIndedx)를 구하고, 이 인덱스를 기준으로 값을 저장한다.
- 평균 시간 복잡도는 O(1)이지만 해시 충돌 발생 시, 최악의 경우 O(n)까지 가능하다.

<br>

### 해시 테이블 구조

| 구성요소          | 설명                                                |
| ------------- | ------------------------------------------------- |
| **Buckets**   | 해시 테이블을 구성하는 배열 전체                                |
| **Bucket**    | Buckets 배열의 각 요소로, **같은 해시 인덱스를 공유하는 데이터 그룹**을 저장 |
| **HashIndex** | 해시 함수로부터 계산된 인덱스 값. Bucket의 위치를 지정함               |


<br>

### 충돌 해결: 체이닝 방식
- 같은 해시 인덱스에 여러 데이터가 매핑될 경우, 해당  Bucket에 선형 자료구조(리스트 등)를 연결해 저장한다.
- 일반적으로 LinkedList를 사용한다.
	- 포인터만 조작해 삽입/삭제가 가능하여 구조 변경 비용이 낮다.
 	- 배열 기반보다 충돌 시 처리 성능이 안정적이다.

<br>

### HashSet
- HashSet은 Set 인터페이스를 구현한 대표적인 클래스이다.
- 객체를 저장할 때 순서를 고려하지 않고, 동일한 객체는 한 번만 저장된다.

<br>

> 여기서 "동일한 객체"란 단순히 같은 인스턴스를 의미하는 것이 아니라, 객체의 `hashCode()`와 `equals()` 메서드의 결과를 기준으로 논리적 동등성을 판단한 것이다.

<br>

### HashSet의 객체 판단 과정
1. 객체를 저장하기 전에 객체의 `hashCode()` 메소드를 호출해 해시코드를 생성한다.
2. 생성된 해시코드를 기반으로, 이미 저장된 객체들과 해시코드가 같은지 비교한다.
3. 해시코드가 같은 경우, 다시 `equals()` 메서드를 사용해 두 객체가 논리적으로 동등한지 판단한다.
4. `equals()` 메서드까지 true를 반환하면, HashSet은 해당 객체가 이미 존재한다고 간주하여 저장하지 않는다.

<br>

## 4. Map 컬렉션
### Map 특징
- **Map 컬렉션은 키(Key)와 값(Value)의 쌍으로 구성된 Entry 객체를 저장하는 구조를 가지고 있다.**
  - 키와 값은 모두 객체로 저장된다.
  - 키는 중복 저장이 불가능하며, 중복된 키로 값을 저장할 경우 기존 값이 새 값으로 대체된다.
  - 값은 중복 저장이 가능하다.
    
<br>

### HashMap
-  HashMap은 Map 인터페이스를 구현한 대표적인 Map 컬렉션이다.
-  HashMap의 키로 사용할 객체는 `hashCode()`와 `equasl()` 메소드를 재정의해서 동등 객체가 될 조건을 명확히 해야한다.
    - 키의 중복 여부를 이 두 메서드를 통해 판단한다.


<br>

### Hashtable
- Hashtable은 HashMap과 동일한 내부 구조를 가지고 있다.
- 차이점은 Hashtable은 동기화된(synchronized) 메소드로 구성되어 있다.

<br>

### Properties
- 애플리케이션이나 데이터베이스 등의 정보가 저장된 프로퍼티(*.properties) 파일을 읽을 때 주로 사용된다.
- 이는 Hashtable의 하위 클래스이기 때문에 Hashtable의 모든 특징을 그대로 가진다.
  - 차이점은 Hashtable은 키와 값을 다양한 타입으로 지정이 가능한데 비해, Properties는 키와 값을 `String`타입으로 제한한 컬렉션이다. 


<br>

## 5. 검색 기능을 강화시킨 컬렉션
### 개요
- 컬렉션 프레임워크는 검색 기능을 강화시킨 TreeSet과 TreeMap을 제공한다.
- 이진 트리를 이용해서 계층적 구조를 가지면서 객체를 .


<br>

### TreeSet
- TreeSet은 Set 인터페이스를 구현한 클래스로, 중복 없이 데이터를 저장한다.
- 내부적으로 이진 탐색 트리를 사용해 저장된 데이터가 항상 오름차순으로 정렬되어 있다.

<br>

### TreeMap
- TreeMap은 Map 인터페이스를 구현한 컬렉션이다.
- 내부 구조는 TreeSet과 비슷한 이진 탐색 트리이며, 키를 기준으로 데이터를 정렬해 저장한다.

<br>

### Compareable, Comparator
- TreeSet과 TreeMap은 저장하는 순간, 자동으로 키나 객체를 오름차순으로 졍렬한다.
- 이를 위해 저장되는 객체는 Comparable 인터페이를 구현해야 한다.
	- Comparable 인터페이스는 `compareTo()` 메서드가 있어서 두 객체를 비교하는 기준을 정할 수 있다.

### TreeSet 객체와 TreeMap의 키가 Comparable을 구현하고 있지 않을 경우
- 저장할 때 `ClassCastException` 오류가 발생한다.
- 자바가 두 객체를 비교하는 방법을 몰라서 발생하는 문제이다.
  

<br>

## 6. LIFO와 FIFO 컬렉션
### 개요
- 후입선출(LIFO: Last In First Out): 나중에 넣은 객체가 먼저 빠져나가는 자료구조
- 선입선출(FIFO: First In First Out): 먼저 넣은 객체가 먼저 빠져나가는 자료구조

> 컬렉션 프레임워크에는 LIFO 자료구조를 제공하는 스택(Stack) 클래스와 FIFO 자료구조를 제공하는 큐(Queue) 인터페이스를 제공하고 있다.

### Stack
- 스택 클래스는 LIFO 자료구조를 구현한 클래스이다.
```java
Stack<E> stack = new Stack<E>();
```
### Queue
- 큐 인터페이스는 FIFO 방식으로 동작한다.
  - Queue 인터페이스를 구현한 대표적인 클래스는 LinkedList이다.
```java
Queue<E> queue = new LinkedList<E>();
```

<br>

## 7. 동기화된 컬렉션
### 개요
- 컬렉션 프레임워크의 대부분의 클래스들은 싱글 스레드 환경에서 사용할 수 있도록 설계됐다.
- 따라서, 여러 스레드가 동시에 컬렉션에 접근한다면 의도하지 않게 요소가 변경될 수 있는 불안전한 상태가 된다.

<br>

> 따라서 컬렉션 프레임워크는 비동기화된 메소드를 동기화된 메소드로 래핑하는 Collections의 sychronizedXXX()의 메소드를 제공하고 있다.

<br>

**동기화된 컬렉션으로 리턴하기**

|리턴 타입|  메소드(매개 변수) | 설명|
|:-------:|:------|:-------|
|List<T> | synchronizedList(List<T> list) | List를 동기화된 List로 리턴|
|Map<K, V> | synchronizedMap(Map<K, V> m) | Map을 동기화된 Map으로 리턴|
|Set<T> | synchronizedSet(Set<T> s) | Set을 동기화된 Set으로 리턴|

<br>



## 8. 병렬 처리를 위한 컬렉션
### 개요
- 동기화된 컬렉션은 멀티 스레드 환경에서 하나의 스레드가 요소를 안전하게 처리하도록 도와주지만, 전체 요소를 빠르게 처리하지는 못한다.
	- 이는 하나의 스레드가 요소를 처리할 때, 전체 잠금이 발생하여 다른 스레드는 대기 상태가 되기 때문이다.

<br>

> 따라서 자바는 멀티 스레드가 병렬적으로 처리할 수 있도록 특별한 컬렉션을 제공한다.

<br>

 ### ConcurrentHashMap
- 스레드에 안전하면서도 멀티 스레드가 요소를 병렬적으로 처리할 수 있게 도와준다.

```java
Map<K, V> map = new ConcurrentHashMap<K, V>();
```
- ConcurrentHashMap은 부분 잠금을 사용한다.
	- 전체 잠금: 1개를 처리할 동안 전체의 10개 요소를 다른 스레드가 처리하지 못하도록 하는 것
 	- 부분 잠금: 처리하는 요소가 포함된 부분만 잠금하고, 나머지 부분은 다른 스레드가 변경할 수 있는 것  

<br>

 ### ConcurrentLinkedQueue
 - 락-프리(lock-free) 알고리즘을 구현한 컬렉션이다.

```java
Queue<E> queue = new ConcurrentLinkedQueue<E>();
```
- 락-프리 알로리즘은 여러 갱의 스레드가 동시에 접근할 경우, 잠금을 사용하지 않도고 최소한 하나의 스레드가 안전하게 요소를 저장하거나 얻도록 해준다.



