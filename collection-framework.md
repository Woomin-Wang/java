# 컬렉션 프레임워크
본 내용은 [이것이 자바다 - 신용권], [김영한 중급 2편]을 참고하여 정리하였습니다.

<br/>

> 1절. 컬렉션 프레임워크 소개 
> 
> 2절. List 컬렉션
>
> 3절. Set 컬렉션
> 
> 4절. Map 컬렉션
>
> 5절. 검색 기능을 강화시킨 컬렉션
>
> 6절. LIFO와 FIFO
> 
> 7절. 동기화된 컬렉션
> 
> 8절. 병렬 처리를 위한 컬렉션

<br/>

## 1. 컬렉션 프레임워크 소개
### 개요
자바는 배열의 한계를 보완하기 위해, 널리 알려진 자료구조들을 기반으로 효율적인 추가, 삭제, 검색이 가능하도록 `java.util` 패키지에 컬렉션과 관련된 인터페이스뿐 아니라 이를 구현한 클래스들까지 포함시켰으며, 이를 컬렉션 프레임워크라고 한다.

<br/>

### 컬렉션
- 사전적 의미로는 요소를 수집해서 저장하는 것을 말한다.
- 자바 컬렉션은 객체를 수집해서 저장하는 역할을 한다.

<br/>

### 프레임 워크
- 사용 방법을 미리 정해 놓은 라이브러리를 말한다.

<br/>

> 아래는 해당 인터페이스를 구현한 클래스들이다.

|인터페이스 분류|    특징 | 구현 클래스|
|:-------:|:------|:-------|
|Collection - <br/>List 계열|순서를 유지하고 저장 <br/>중복 저장 가능 | ArrayList, Vector, LinkedList|
|Collection - <br/>Set 계열|순서를 유지하지 않고 저장 <br/>중복 저장 안됨 | HashSet, TreeSet|
|Map 계열|키와 값의 쌍으로 저장 <br/> 키는 중복 저장 안됨 | HashMap, Hashtable, <br/> TreeMap, Properties|

<br/>


## 2. List 컬렉션
### List 특징
- List 컬렉션은 객체를 일렬로 나열한 구조를 가지고 있다.
- 객체를 인덱스로 관리하기 때문에, 객체를 저장하면 자동으로 인덱스가 부여된다.
- List는 객체 자체를 저장하는 것이 아니라, 객체의 참조(번지)를 저장한다.

<br/>

### ArrayList
- List 인터페이스의 구현 클래스로, 여기에 객체를 추가하면 객체가 인덱스로 관리한다.
  - 내부적으로는 배열을 기반으로 하며, 인덱스를 이용해 객체를 관리한다.
  - 일반 배열과 달리 생성 시 크기를 고정할 필요가 없고, 저장 용량(capacity)을 초과하면 자동으로 용량이 증가한다.
  - 중간이나 앞부분에 데이터를 삽입하거나 삭제할 경우, 뒤쪽 요소들을 한 칸씩 이동시켜야 하므로 성능이 O(n)으로 저하된다.

<br/>

> 따라서, 빈번한 객체 삽입 및 삭제가 필요한 경우에는 `ArrayList`보다는 `LinkedList` 사용이 더 적절하다.

<br/>

### Vector
- 내부 구조는 `ArrayList`와 동일하지만, `Vector`는 동기화된(synchronized) 메서드로 구성되어 있다.
- 멀티 스레스가 동시에 이 메서드를 실행할 수 없다.
  - 이를 스레드가 안전(Thread Safe)하다라고 말한다. 

<br/>

### LinkedList
- LinkedList는 ArrayList와 사용 방법은 비슷하지만 내부 구조는 완전히 다르다.
- LinkedList는 인접 노드를 참조(링크)하여 체인 형태로 요소를 연결한다.
  - 단일 연결이 아닌 이중 연결 리스트 구조를 가지고 있다.
- 특정 인덱스의 요소를 제거하거나 삽입할 때는 앞뒤 노드의 참조만 변경하면 된다.
  - 삭제와 삽입이 빈번히 발생하는 상황에서 우수한 성능을 발휘한다.
 
<br/>

### ArrayList와 LinkedList 비교

| 기능           | **배열 리스트 (ArrayList)** | **연결 리스트 (LinkedList)** |
| ------------ | ---------------------- | ----------------------- |
| **앞에 추가/삭제** | O(n) – 106ms           | O(1) – 2ms              |
| **평균 추가/삭제** | O(n) – 49ms            | O(n) – 1116ms           |
| **뒤에 추가/삭제** | O(1) – 1ms             | O(1) – 2ms              |
| **인덱스 조회**   | O(1) – 1ms             | O(n) – 평균 439ms         |
| **검색**       | O(n) – 평균 104ms        | O(n) – 평균 473ms         |

전체적인 내용 정리 필요



<br/>

## 3. Set 컬렉션
### Set 특징
- Set 컬렉션은 List와 달리 저장 순서가 유지되지 않으며, 중복된 객체를 저장할 수 없다.
- `null` 값은 하나만 저장할 수 있다. (중복된 null은 허용되지 않음)

  
<br>

### Set 이해
- Set은 수학의 집합 개념과 유사하다.
  - 집합은 순서를 고려하지 않으며, 중복된 요소를 허용하지 않는다.
  - 저장된 순서와 출력되는 순서가 다를 수 있다.
 
<br>

### Set 차별점
- Set은 인덱스를 기반으로 개별 객체를 검색할 수 있는 메서드를 제공하지 않는다.
- 대신, 저장된 전체 객체를 반복하여 접근할 수 있는 반복자(Iterator)를 제공한다.
  - Iterator `iterator()` 메서드를 통해 얻을 수 있으며, 내부적으로 객체를 하나씩 순차적으로 반환한다.

<br>

**Iterator 사용 예시**
```java
Set<String> set = ...;
Iterator<String> iterator = set.iterator();

while(iterator.hasNext()) { // 가져올 객체가 있는지 확인
	String str = iterator.next(); //객체 반환
	if(str.equals("홍길동")) {
		iterator.remove(); 
        //remove는 Iterator의 메소드이지만, 실제 Set 컬렉션에서 객체가 제거
	}
}
```

<br>

### HashSet
- HashSet은 Set 인터페이스를 구현한 대표적인 클래스이다.
- 객체를 저장할 때 순서를 고려하지 않고, 동일한 객체는 한 번만 저장된다.

<br>

> 여기서 "동일한 객체"란 단순히 같은 인스턴스를 의미하는 것이 아니라, 객체의 `hashCode()`와 `equals()` 메서드의 결과를 기준으로 논리적 동등성을 판단한 것이다.

<br>

### HashSet의 객체 판단 과정
1. 객체를 저장하기 전에 객체의 `hashCode()` 메소드를 호출해 해시코드를 생성한다.
2. 생성된 해시코드를 기반으로, 이미 저장된 객체들과 해시코드가 같은지 비교한다.
3. 해시코드가 같은 경우, 다시 `equals()` 메서드를 사용해 두 객체가 논리적으로 동등한지 판단한다.
4. `equals()` 메서드까지 true를 반환하면, HashSet은 해당 객체가 이미 존재한다고 간주하여 저장하지 않는다.

<br>

## 4. Map 컬렉션
### Map 특징
- **Map 컬렉션은 키(Key)와 값(Value)의 쌍으로 구성된 Entry 객체를 저장하는 구조를 가지고 있다.**
  - 키와 값은 모두 객체로 저장된다.
  - 키는 중복 저장이 불가능하며, 중복된 키로 값을 저장할 경우 기존 값이 새 값으로 대체된다.
  - 값은 중복 저장이 가능하다.
    
<br>

### HashMap
-  HashMap은 Map 인터페이스를 구현한 대표적인 Map 컬렉션이다.
-  HashMap의 키로 사용할 객체는 `hashCode()`와 `equasl()` 메소드를 재정의해서 동등 객체가 될 조건을 명확히 해야한다.
    - 키의 중복 여부를 이 두 메서드를 통해 판단한다.


<br>

### Hashtable
- Hashtable은 HashMap과 동일한 내부 구조를 가지고 있다.
- 차이점은 Hashtable은 동기화된(synchronized) 메소드로 구성되어 있다.

<br>

### Properties
- 애플리케이션이나 데이터베이스 등의 정보가 저장된 프로퍼티(*.properties) 파일을 읽을 때 주로 사용된다.
- 이는 Hashtable의 하위 클래스이기 때문에 Hashtable의 모든 특징을 그대로 가진다.
  - 차이점은 Hashtable은 키와 값을 다양한 타입으로 지정이 가능한데 비해, Properties는 키와 값을 `String`타입으로 제한한 컬렉션이다. 


<br>

## 5. 검색 기능을 강화시킨 컬렉션
### 개요
- 컬렉션 프레임워크는 검색 기능을 강화시킨 TreeSet과 TreeMap을 제공한다.
  - 이 컬렉션들은 이진 트리를 이용해서 계층적 구조를 가지면서 객체를 저장한다.

<br>

### TreeSet
- 이진 트리를 기반으로 한 Set 컬렉션이다.

<br>

### 사용하는 이유
- Set 인터페이스 타입 변수에 대입해도 되지만 

<br>

### TreeMap

<br>


## 6. LIFO와 FIFO 컬렉션
### 개요
- 후입선출(LIFO: Last In First Out): 나중에 넣은 객체가 먼저 빠져나가는 자료구조
- 선입선출(FIFO: First In First Out): 먼저 넣은 객체가 먼저 빠져나가는 자료구조

> 컬렉션 프레임워크에는 LIFO 자료구조를 제공하는 스택(Stack) 클래스와 FIFO 자료구조를 제공하는 큐(Queue) 인터페이스를 제공하고 있다.

### Stack
- 스택 클래스는 LIFO 자료구조를 구현한 클래스이다.
```java
Stack<E> stack = new Stack<E>();
```
### Queue
- 큐 인터페이스는 FIFO 방식으로 동작한다.
  - Queue 인터페이스를 구현한 대표적인 클래스는 LinkedList이다.
```java
Queue<E> queue = new LinkedList<E>();
```










