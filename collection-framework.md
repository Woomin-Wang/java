# 컬렉션 프레임워크
본 내용은 [이것이 자바다 - 신용권], [김영한 중급 2편]을 참고하여 정리하였습니다.

<br/>

> 1절. 컬렉션 프레임워크 소개 
> 
> 2절. List 컬렉션
>
> 3절. Set 컬렉션
> 
> 4절. Map 컬렉션
>
> 5절. 검색 기능을 강화시킨 컬렉션
>
> 6절. LIFO와 FIFO
> 
> 7절. 동기화된 컬렉션
> 
> 8절. 병렬 처리를 위한 컬렉션

<br/>

## 1. 컬렉션 프레임워크 소개
### 개요
자바는 배열의 한계를 보완하기 위해, 널리 알려진 자료구조들을 기반으로 효율적인 추가, 삭제, 검색이 가능하도록 `java.util` 패키지에 컬렉션과 관련된 인터페이스뿐 아니라 이를 구현한 클래스들까지 포함시켰으며, 이를 컬렉션 프레임워크라고 한다.

<br/>

### 컬렉션
- 사전적 의미로는 요소를 수집해서 저장하는 것을 말한다.
- 자바 컬렉션은 객체를 수집해서 저장하는 역할을 한다.

<br/>

### 프레임 워크
- 사용 방법을 미리 정해 놓은 라이브러리를 말한다.

<br/>

> 아래는 해당 인터페이스를 구현한 클래스들이다.

|인터페이스 분류|    특징 | 구현 클래스|
|:-------:|:------|:-------|
|Collection - <br/>List 계열|순서를 유지하고 저장 <br/>중복 저장 가능 | ArrayList, Vector, LinkedList|
|Collection - <br/>Set 계열|순서를 유지하지 않고 저장 <br/>중복 저장 안됨 | HashSet, TreeSet|
|Map 계열|키와 값의 쌍으로 저장 <br/> 키는 중복 저장 안됨 | HashMap, Hashtable, <br/> TreeMap, Properties|

<br/>

![image](https://github.com/user-attachments/assets/b967e5a0-5e49-4a83-b47b-2eafda1215f7)

<br/>

## 2. List 컬렉션
### List 특징
- List 컬렉션은 객체를 일렬로 나열한 구조를 가지고 있다.
- 객체를 인덱스로 관리하기 때문에, 객체를 저장하면 자동으로 인덱스가 부여된다.
- List는 객체 자체를 저장하는 것이 아니라, 객체의 참조(번지)를 저장한다.

<br/>

### ArrayList
- List 인터페이스의 구현 클래스로, 여기에 객체를 추가하면 객체가 인덱스로 관리된다.
  - 일반 배열처럼 인덱스를 이용해 객체를 관리한다는 점에서 유사하다.
  - 하지만 배열은 생성 시 크기가 고정되어 이후 변경할 수 없는 반면,
  - ArrayList는 저장 용량(capacity)을 초과한 객체들이 들어오면 자동적으로 저장 용량이 증가한다.

<br/>

단, 맨 마지막이 아닌 위치에서 삽입하거나 삭제할 경우, 뒤쪽 요소들을 한 칸씩 이동시켜야 하므로 성능이 O(n)만큼 저하된다.

<br/>

> 따라서, 빈번한 객체 삽입 및 삭제가 필요한 경우에는 `ArrayList`보다는 `LinkedList` 사용이 더 적절하다.

<br/>

### Vector
- 내부 구조는 `ArrayList`와 동일하지만, `Vector`는 동기화된(synchronized) 메서드로 구성되어 있다.


<br/>

### LinkedList
- LinkedList는 ArrayList와 사용 방법은 비슷하지만 내부 구조는 완전히 다르다.
- LinkedList는 인접 노드를 참조(링크)하여 체인 형태로 요소를 연결하며, 단일 연결이 아닌 이중 연결 리스트 구조를 가지고 있다.
- 따라서, 특정 인덱스의 요소를 제거하거나 삽입할 때는 앞뒤 노드의 참조만 바꾸면 되므로, 삭제와 삽입이 빈번히 발생하는 상황에서 우수한 성능을 발휘한다.
 
<br/>

### ArrayList와 LinkedList 비교

| 기능           | **배열 리스트 (ArrayList)** | **연결 리스트 (LinkedList)** |
| ------------ | ---------------------- | ----------------------- |
| **앞에 추가/삭제** | O(n) – 106ms           | O(1) – 2ms              |
| **평균 추가/삭제** | O(n) – 49ms            | O(n) – 1116ms           |
| **뒤에 추가/삭제** | O(1) – 1ms             | O(1) – 2ms              |
| **인덱스 조회**   | O(1) – 1ms             | O(n) – 평균 439ms         |
| **검색**       | O(n) – 평균 104ms        | O(n) – 평균 473ms         |


추가/ 삭제 성능
- ArrayList는 인덱스를 이용해 위치를 바로 찾을 수 있지만, 삽입/삭제 후 데이터를 한 칸씩 옮겨야 하므로 O(n) 시간이 걸린다.
- LinkedLis는 인덱스로 위치를 찾는 데 시간이 오래 걸리지만(O(n)), 실제 삽입/삭제는 포인터만 바꾸면 되기 때문에 O(1)로 빠르다.

앞쪽에 추가/삭제
- ArrayList: 위치는 금방 찾미나 이동 비용으로 O(n)
- LikedList: 처음 노드를 바로 바꾸면 되므로 O(1)

중간에 추가/삭제
- ArrayList: 위치는 O(1), 데이터 밀기 O(n)
- LikedList: 위치 탐색 O(n), 참조 수정 O(1) → 총 O(n)

뒤쪽에 추가/삭제
- 둘 다 O(1)
  - LinkedList는 마지막 노드를 참조로 저장하고 있어서 가능하다. 

인덱스로 조회
- ArrayList: 배열이므로 O(1)
- LikedList: 청므부터 따라가야 하므로 O(n)

검색
- 둘 다 전체 탐색이 필요하므로 O(n)

실제 성능이 ArrayList가 좋은 이유
- ArrayList는 내부적으로 메모리 고속 복사를 사용해 데이터 이동을 빠르게 처리한다.
- 요소가 연속된 메모리 공간에 있어 CPU 캐시 효율이 좋다.
- 반면 LinkedList는 노드가 훝어져 있어 캐시 효율이 떨어진다.

> 일반적인 상황에서는 ArrayList가 성능상 유리해서 실무에서 자주 사용되지만 앞쪽 삽입/삭제가 매우 빈허


<br/>

## 3. Set 컬렉션










